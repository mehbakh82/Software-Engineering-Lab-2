# آزمایشگاه مهندسی نرم‌افزار - تمرین دوم: پیام‌رسان قزمیت

این پروژه جهت انجام تمرین دوم آزمایشگاه مهندسی نرم‌افزار آماده شده است. در این تمرین، یک سرویس پیام‌رسان تلگرام به دو روش مختلف به پروژه پایه اضافه شده است: یک بار بدون رعایت اصول SOLID و بار دیگر با بازنویسی کد بر اساس این اصول.

## مرحله اول: افزودن سرویس تلگرام بدون رعایت اصول SOLID

کد نهایی این مرحله در پوشه‌ی `Step-01-without-solid` قرار دارد.

## مرحله دوم: ثبت تغییرات اعمال‌شده

برای افزودن قابلیت ارسال پیام تلگرام، تغییرات زیر در کد پایه اعمال شد:

| ردیف | محل اعمال تغییرات (کلاس/واسط) | عنوان تغییر | شرحی کوتاه از تغییر |
| :--: | :--- | :--- | :--- |
| ۱ | `MessageService` | افزودن متد `sendTelegramMessage` | یک متد جدید برای ارسال پیام تلگرام به اینترفیس اضافه شد. |
| ۲ | `SmsMessageService` | پیاده‌سازی متد `sendTelegramMessage` | متد جدید با بدنه‌ی خالی پیاده‌سازی شد تا کلاس دچار خطای کامپایل نشود. |
| ۳ | `EmailMessageService` | پیاده‌سازی متد `sendTelegramMessage` | متد جدید با بدنه‌ی خالی پیاده‌سازی شد تا کلاس دچار خطای کامپایل نشود. |
| ۴ | `Main` | افزودن گزینه‌ی تلگرام | گزینه‌ی ۳ برای دریافت ورودی پیام تلگرام به منو اضافه شد. |
| ۵ | `Main` | افزودن منطق شرطی برای تلگرام | یک بلاک `else if` برای ساختن سرویس تلگرام و ارسال پیام اضافه شد. |
| ۶ | - | افزودن کلاس `TelegramMessage` | کلاس مدل برای پیام تلگرام ایجاد شد. |
| ۷ | - | افزودن کلاس `TelegramMessageService` | کلاس سرویس برای منطق ارسال پیام تلگرام ایجاد شد. |

**تعداد کل تغییرات:** ۷ مورد (۲ کلاس جدید، ۵ تغییر در فایل‌های موجود)

## مرحله سوم: تحلیل نقض اصول SOLID

| اصل | موارد تحقق | موارد نقض |
| :--- | :--- | :--- |
| **اصل ۲: Open-Close Principle (OCP)** | - | این اصل به وضوح نقض شده است. برای افزودن یک قابلیت جدید (سرویس تلگرام)، مجبور به تغییر کدهای موجود در کلاس‌های `Main`، `MessageService`، `SmsMessageService` و `EmailMessageService` شدیم. این کلاس‌ها برای توسعه باز نبودند و برای تغییر نیز بسته نبودند. |
| **اصل ۳: Liskov Substitution Principle** | این اصل برقرار است. می‌توان یک شی از `SmsMessageService` را با `MessageService` جایگزین کرد و برنامه دچار خطا نمی‌شود. هرچند پیاده‌سازی متدهای خالی نشان از طراحی ضعیف دارد که در اصل بعدی بررسی می‌شود. | - |
| **اصل ۴: Interface Segregation** | - | این اصل نقض شده است. اینترفیس `MessageService` یک اینترفیس "چاق" (Fat Interface) است. کلاس‌هایی مانند `SmsMessageService` مجبور به پیاده‌سازی متدهایی (`sendEmailMessage` و `sendTelegramMessage`) شده‌اند که به آن‌ها هیچ نیازی ندارند. |
| **اصل ۵: Dependency Inversion** | - | این اصل نقض شده است. ماژول سطح بالا (`Main`) به طور مستقیم به ماژول‌های سطح پایین (کلاس‌های کانکریت `SmsMessageService` و `EmailMessageService`) وابستگی دارد. (`new SmsMessageService()`). این وابستگی مستقیم، انعطاف‌پذیری سیستم را به شدت کاهش می‌دهد. |

## مرحله چهارم: ارائه راه‌حل برای برقراری اصول

| اصل مربوطه (از اصول SOLID) | علت نقض | راه حل پیشنهادی |
| :--- | :--- | :--- |
| **Open-Close Principle (OCP)** | نیاز به تغییر کد موجود برای افزودن قابلیت جدید. | **۱. استفاده از اینترفیس جنریک:** اینترفیس `MessageService` را به صورت جنریک (`MessageService<T extends Message>`) تعریف می‌کنیم تا تنها یک متد `sendMessage` داشته باشد. **۲. استفاده از الگوی Factory:** یک کلاس `MessageServiceFactory` ایجاد می‌کنیم که مسئولیت ساخت سرویس مناسب را بر عهده بگیرد. کلاس `Main` دیگر به طور مستقیم سرویس‌ها را `new` نمی‌کند و در نتیجه برای افزودن سرویس جدید نیازی به تغییر آن نیست. |
| **Interface Segregation (ISP)** | وجود متدهای غیرمرتبط در اینترفیس `MessageService` برای کلاس‌های پیاده‌ساز. | **استفاده از اینترفیس جنریک:** با تعریف اینترفیس به صورت `MessageService<T extends Message>`، هر کلاس سرویس تنها متدی را پیاده‌سازی می‌کند که به آن نیاز دارد و متدهای اضافی حذف می‌شوند. این راهکار مشکل هر دو اصل OCP و ISP را حل می‌کند. |
| **Dependency Inversion (DIP)** | وابستگی مستقیم ماژول سطح بالا (`Main`) به پیاده‌سازی‌های سطح پایین (سرویس‌های کانکریت). | **استفاده از الگوی Factory:** با معرفی `MessageServiceFactory`، وابستگی کلاس `Main` از کلاس‌های کانکریت به یک کلاس انتزاعی (Factory) منتقل می‌شود. `Main` دیگر نیازی به دانستن نحوه‌ی ساخت سرویس‌ها ندارد و تنها از Factory سرویس مورد نظر خود را درخواست می‌کند. |

## سوالات پایانی

**۱. اگر اصول شی‌گرایی از ابتدا برقرار بود و شما سرویس جدید را به پروژه اضافه می‌کردید، چند مورد از تغییرات ثبت شده در جدول مرحله دوم حذف می‌شد؟ و در نهایت با چند تغییر در سطح کد، این سرویس اضافه می‌شد؟**

در صورت طراحی صحیح، ۵ مورد از تغییرات ثبت‌شده حذف می‌شد. تغییرات در `MessageService`، `SmsMessageService`، `EmailMessageService` و منطق شرطی `if/else` در `Main` دیگر لازم نبود.
سرویس جدید تنها با **۳ تغییر** اضافه می‌شد:
1.  ایجاد کلاس `TelegramMessage.java`.
2.  ایجاد کلاس `TelegramMessageService.java`.
3.  افزودن یک `case` جدید به کلاس `MessageServiceFactory` برای ساخت سرویس تلگرام.

**۲. با توجه به آنچه که انجام دادید، در دو خط توضیح دهید که رعایت اصول شی‌گرایی، چه مزایایی را برای پروژه شما فراهم می‌کند؟**

رعایت اصول شی‌گرایی (SOLID) باعث می‌شود کد **قابل نگهداری (Maintainable)** و **قابل توسعه (Extensible)** باشد. افزودن قابلیت‌های جدید با حداقل تغییرات در کد موجود و با ریسک پایین‌تر امکان‌پذیر می‌شود و پیچیدگی سیستم در طول زمان کنترل می‌شود.